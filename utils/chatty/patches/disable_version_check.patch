# disable version check. updates come via package management
--- a/src/chatty/Chatty.java
+++ b/src/chatty/Chatty.java
@@ -57,7 +57,7 @@
      * Enable Version Checker (if you compile and distribute this yourself, you
      * may want to disable this)
      */
-    public static final boolean VERSION_CHECK_ENABLED = true;
+    public static final boolean VERSION_CHECK_ENABLED = false;
     
     /**
      * The regular URL of the textfile where the most recent version is stored.
--- a/src/chatty/TwitchClient.java
+++ b/src/chatty/TwitchClient.java
@@ -79,16 +79,16 @@
 
 /**
  * The main client class, responsible for managing most parts of the program.
- * 
+ *
  * @author tduva
  */
 public class TwitchClient {
-    
+
     private static final Logger LOGGER = Logger.getLogger(TwitchClient.class.getName());
-    
+
     private volatile boolean shuttingDown = false;
     private volatile boolean settingsAlreadySavedOnExit = false;
-    
+
     /**
      * The URL to get a token. Needs to end with the scopes so other ones can be
      * added.
@@ -105,87 +105,87 @@
      * Holds the Settings object, which is used to store and retrieve renametings
      */
     public final Settings settings;
-    
+
     public final ChatLog chatLog;
-    
+
     private final TwitchConnection c;
-    
+
     /**
      * Holds the TwitchApi object, which is used to make API requests
      */
     public final TwitchApi api;
-    
+
     public final chatty.util.api.pubsub.Manager pubsub;
     private final PubSubResults pubsubListener = new PubSubResults();
-    
+
     public final TwitchEmotes twitchemotes;
-    
+
     public final BTTVEmotes bttvEmotes;
-    
+
     public final FrankerFaceZ frankerFaceZ;
-    
+
     public final ChannelFavorites channelFavorites;
-    
+
     public final UsercolorManager usercolorManager;
-    
+
     public final UsericonManager usericonManager;
-    
+
     public final Addressbook addressbook;
-    
+
     public final SpeedrunsLive speedrunsLive;
-    
+
     public final Speedruncom speedruncom;
-    
+
     public final StatusHistory statusHistory;
-    
+
     public final StreamStatusWriter streamStatusWriter;
-    
+
     protected final BotNameManager botNameManager;
-    
+
     protected final CustomNames customNames;
-    
+
     private final AutoModCommandHelper autoModCommandHelper;
-    
+
     public final RoomManager roomManager;
-    
+
     /**
      * Holds the UserManager instance, which manages all the user objects.
      */
     //protected UserManager users = new UserManager();
-    
+
     /**
      * A reference to the Main Gui.
      */
     protected MainGui g;
-    
+
     private final List<String> cachedDebugMessages = new ArrayList<>();
     private final List<String> cachedWarningMessages = new ArrayList<>();
-    
+
     /**
      * User used for testing without connecting.
      */
     private User testUser;
     private final StreamInfo testStreamInfo = new StreamInfo("testStreamInfo", null);
-    
+
     private Webserver webserver;
     private final SettingsManager settingsManager;
     private final SpamProtection spamProtection;
     public final CustomCommands customCommands;
-    
+
     private final StreamHighlightHelper streamHighlights;
-    
+
     private final Set<String> refreshRequests = Collections.synchronizedSet(new HashSet<String>());
-    
+
     private final WhisperManager w;
     private final IrcLogger ircLogger;
-    
+
     private boolean fixServer = false;
-    
+
     public TwitchClient(Map<String, String> args) {
         // Logging
         new Logging(this);
         Thread.setDefaultUncaughtExceptionHandler(new ErrorHandler());
-        
+
         LOGGER.info("### Log start ("+DateTime.fullDateTime()+")");
         LOGGER.info(Chatty.chattyVersion());
         LOGGER.info(Helper.systemInfo());
@@ -193,7 +193,7 @@
                 +" [Settings Directory] "+Chatty.getUserDataDirectory()
                 +" [Classpath] "+System.getProperty("java.class.path"));
         LOGGER.info("Retina Display: "+GuiUtil.hasRetinaDisplay());
-        
+
         settings = new Settings(Chatty.getUserDataDirectory()+"settings");
         // Settings
         settingsManager = new SettingsManager(settings);
@@ -203,7 +203,7 @@
         settingsManager.loadCommandLineSettings(args);
         settingsManager.overrideSettings();
         settingsManager.debugSettings();
-        
+
         addressbook = new Addressbook(Chatty.getUserDataDirectory()+"addressbook",
             Chatty.getUserDataDirectory()+"addressbookImport.txt", settings);
         addressbook.loadFromFile();
@@ -211,9 +211,9 @@
         if (settings.getBoolean("abAutoImport")) {
             addressbook.enableAutoImport();
         }
-        
+
         initDxSettings();
-        
+
         if (settings.getBoolean("splash")) {
             Splash.initSplashScreen(Splash.getLocation((String)settings.mapGet("windows", "main")));
         }
@@ -247,28 +247,28 @@
         settings.addSettingsListener(new SettingSaveListener());
 
         streamHighlights = new StreamHighlightHelper(settings, api);
-        
+
         customNames = new CustomNames(settings);
-        
+
         chatLog = new ChatLog(settings);
         chatLog.start();
-        
+
         testUser.setUsericonManager(usericonManager);
         testUser.setUsercolorManager(usercolorManager);
         testUser.setAddressbook(addressbook);
-        
+
         speedrunsLive = new SpeedrunsLive();
         speedruncom = new Speedruncom(api);
-        
+
         statusHistory = new StatusHistory(settings);
         settings.addSettingsListener(statusHistory);
-        
+
         spamProtection = new SpamProtection();
         spamProtection.setLinesPerSeconds(settings.getString("spamProtection"));
-        
+
         roomManager = new RoomManager(api, new MyRoomUpdatedListener());
         channelFavorites = new ChannelFavorites(settings, roomManager);
-        
+
         c = new TwitchConnection(new Messages(), settings, "main", roomManager);
         c.setAddressbook(addressbook);
         c.setCustomNamesManager(customNames);
@@ -277,26 +277,26 @@
         c.setBotNameManager(botNameManager);
         c.addChannelStateListener(new ChannelStateUpdater());
         c.setMaxReconnectionAttempts(settings.getLong("maxReconnectionAttempts"));
-        
+
         w = new WhisperManager(new MyWhisperListener(), settings, c);
-        
+
         streamStatusWriter = new StreamStatusWriter(Chatty.getUserDataDirectory(), api);
         streamStatusWriter.setSetting(settings.getString("statusWriter"));
         streamStatusWriter.setEnabled(settings.getBoolean("enableStatusWriter"));
         settings.addSettingChangeListener(streamStatusWriter);
-        
+
         LaF.setSettings(settings);
         LaF.setLookAndFeel(settings.getString("laf"), settings.getString("lafTheme"));
         GuiUtil.addMacKeyboardActions();
-        
+
         // Create GUI
         LOGGER.info("Create GUI..");
         g = new MainGui(this);
         g.loadSettings();
         g.showGui();
-        
+
         autoModCommandHelper = new AutoModCommandHelper(g, api);
-        
+
         if (Chatty.DEBUG) {
             getSpecialUser().setEmoteSets("130,4280,33,42,19194");
             Room testRoom =  Room.createRegular("#tduva");
@@ -368,28 +368,28 @@
 //            g.addUser("", new User("bll", ""));
 //            g.addUser("", new User("bzp______________", ""));
 //            g.addUser("", new User("7_dm", ""));
-            
+
             String[] chans = new String[]{"europeanspeedsterassembly","esamarathon2","heinki","joshimuz","lotsofs","test","a","b","c"};
             for (String chan : chans) {
                 //g.printLine(chan, "test");
             }
         }
     }
-    
+
     public void init() {
         LOGGER.info("GUI shown");
         Splash.closeSplashScreen();
-        
+
         // Output any cached warning messages
         warning(null);
-        
+
         // Before checkNewVersion(), so "updateAvailable" is already updated
         checkForVersionChange();
         // Check version, if enabled in this build
         if (Chatty.VERSION_CHECK_ENABLED) {
-            checkNewVersion();
+            //checkNewVersion();
         }
-        
+
         // Connect or open connect dialog
         if (settings.getBoolean("connectOnStartup")) {
             prepareConnection();
@@ -408,19 +408,19 @@
                     prepareConnectionWithChannel(Helper.buildStreamsString(channelFavorites.getFavorites()));
                     break;
             }
-            
+
         }
-        
+
         new UpdateTimer(g);
-        
+
         // Shutdown hook
         Runtime.getRuntime().addShutdownHook(new Thread(new Shutdown(this)));
-        
+
         if (Chatty.DEBUG) {
             //textInput(Room.EMPTY, "/test3");
         }
     }
-    
+
 
     /**
      * Based on the current renametings, rename the system properties to disable
@@ -438,12 +438,12 @@
             LOGGER.warning("Error setting drawing settings: "+ex.getLocalizedMessage());
         }
     }
-    
+
     /**
      * Check if the current version (Chatty.VERSION) is different from the
      * "currentVersion" in the settings, which means a different version is
      * being run compared to the last time.
-     * 
+     *
      * If a new version is detected, updates the "currentVersion" setting,
      * clears the "updateAvailable" setting and opens the release info.
      */
@@ -456,26 +456,19 @@
             g.openReleaseInfo();
         }
     }
-    
+
     /**
      * Checks for a new version if the last check was long enough ago.
      */
     private void checkNewVersion() {
-        Version.check(settings, (newVersion,releases) -> {
-            if (newVersion != null) {
-                g.setUpdateAvailable(newVersion, releases);
-            } else {
-                g.printSystem("You already have the newest version.");
-            }
-        });
     }
-    
+
     /**
      * Creates the test user, also allowing it to be recreated with another name
      * or channel for testing while the programm is running.
-     * 
+     *
      * @param name
-     * @param channel 
+     * @param channel
      */
     private void createTestUser(String name, String channel) {
         testUser = new User(name, name, Room.createRegular(channel));
@@ -496,11 +489,11 @@
 //        badgesTest.put("bits", "1000000");
         testUser.setTwitchBadges(badgesTest);
     }
-    
+
     /**
      * Close all channels except the ones in the given Array.
-     * 
-     * @param except 
+     *
+     * @param except
      */
     private void closeAllChannelsExcept(String[] except) {
         Set<String> copy = c.getOpenChannels();
@@ -510,12 +503,12 @@
             }
         }
     }
-    
+
     /**
      * Close a channel by either parting it if it is currently joined or
      * just closing the tab.
-     * 
-     * @param channel 
+     *
+     * @param channel
      */
     public void closeChannel(String channel) {
         if (c.onChannel(channel)) {
@@ -530,7 +523,7 @@
             chatLog.closeChannel(room.getFilename());
         }
     }
-    
+
     private void closeChannelStuff(Room room) {
         // Check if not on any associated channel anymore
         if (!c.onOwnerChannel(room.getOwnerChannel())) {
@@ -538,7 +531,7 @@
             pubsub.unlistenModLog(room.getStream());
         }
     }
-    
+
     private void addressbookCommands(String channel, User user, String text) {
         if (settings.getString("abCommandsChannel").equalsIgnoreCase(channel)
                 && user.isModerator()) {
@@ -559,41 +552,41 @@
     public String getUsername() {
         return c.getUsername();
     }
-    
+
     public User getUser(String channel, String name) {
         return c.getUser(channel, name);
     }
-    
+
     public User getExistingUser(String channel, String name) {
         return c.getExistingUser(channel, name);
     }
-    
+
     public void clearUserList() {
         c.setAllOffline();
         g.clearUsers(null);
     }
-    
+
     private String getServer() {
         String serverDefault = settings.getString("serverDefault");
         String serverTemp = settings.getString("server");
         return serverTemp.length() > 0 ? serverTemp : serverDefault;
     }
-    
+
     private String getPorts() {
         String portDefault = settings.getString("portDefault");
         String portTemp = settings.getString("port");
         return portTemp.length() > 0 ? portTemp : portDefault;
     }
-    
+
     /**
      * Prepare connection using renametings and default server.
-     * 
-     * @return 
+     *
+     * @return
      */
     public final boolean prepareConnection() {
         return prepareConnection(getServer(), getPorts());
     }
-    
+
     public boolean prepareConnection(boolean rejoinOpenChannels) {
         if (rejoinOpenChannels) {
             return prepareConnection(getServer(), getPorts(), null);
@@ -601,15 +594,15 @@
             return prepareConnection();
         }
     }
-    
+
     public final boolean prepareConnectionWithChannel(String channel) {
         return prepareConnection(getServer(), getPorts(), channel);
     }
-    
+
     public boolean prepareConnection(String server, String ports) {
         return prepareConnection(server, ports, settings.getString("channel"));
     }
-    
+
     public final boolean prepareConnectionAnyChannel(String server, String ports) {
         String channel = null;
         if (c.getOpenChannels().isEmpty()) {
@@ -617,7 +610,7 @@
         }
         return prepareConnection(server, ports, channel);
     }
-    
+
     /**
      * Prepares the connection while getting everything from the renametings,
      * except the server/port.
@@ -631,39 +624,39 @@
         String password = settings.getString("password");
         boolean usePassword = settings.getBoolean("usePassword");
         String token = settings.getString("token");
-        
+
         String login = "oauth:"+token;
         if (token.isEmpty()) {
             login = "";
         }
-        
+
         if (usePassword) {
             login = password;
             LOGGER.info("Using password instead of token.");
         }
-        
+
         return prepareConnection(username,login,channel,server, ports);
     }
-    
+
     /**
      * Prepare connection using given credentials and channel, but use default
      * server.
-     * 
+     *
      * @param name
      * @param password
      * @param channel
-     * @return 
+     * @return
      */
 //    public boolean prepareConnection(String name, String password, String channel) {
 //        return prepareConnection(name, password, channel, getServer(), getPorts());
 //    }
-    
+
     /**
      * Prepares the connection to the given channel with the given credentials.
-     * 
+     *
      * This does stuff that should only be done once, unless the given parameters
      * change. So this shouldn't be repeated for just reconnecting.
-     * 
+     *
      * @param name The username to use for connecting.
      * @param password The password to connect with.
      * @param channel The channel(s) to join after connecting, if this is null
@@ -674,19 +667,19 @@
      */
     public boolean prepareConnection(String name, String password,
             String channel, String server, String ports) {
-        
+
         fixServer = false;
-        
+
         if (c.getState() > Irc.STATE_OFFLINE) {
             g.showMessage("Cannot connect: Already connected.");
             return false;
         }
-        
+
         if (name == null || name.isEmpty() || password == null || password.isEmpty()) {
             g.showMessage("Cannot connect: Incomplete login data.");
             return false;
         }
-        
+
         String[] autojoin;
         Set<String> openChannels = c.getOpenChannels();
         if (channel == null) {
@@ -699,14 +692,14 @@
             g.showMessage("A channel to join has to be specified.");
             return false;
         }
-        
+
         if (server == null || server.isEmpty()) {
             g.showMessage("Invalid server specified.");
             return false;
         }
-        
+
         closeAllChannelsExcept(autojoin);
-        
+
         settings.setString("username", name);
         if (channel != null) {
             settings.setString("channel", channel);
@@ -778,15 +771,15 @@
                     g.printLine("Not in a channel");
                 }
             }
-        }     
+        }
     }
-    
+
     private void sendMessage(String channel, String text) {
         sendMessage(channel, text, false);
     }
-    
+
     /**
-     * 
+     *
      * @param channel
      * @param text
      * @param allowCommandMessageLocally Commands like !highlight, which
@@ -804,48 +797,48 @@
             g.printLine("# Message not sent to prevent ban: " + text);
         }
     }
-    
+
     /**
      * Checks if the given channel should be open.
-     * 
+     *
      * @param channel The channel name
-     * @return 
+     * @return
      */
     public boolean isChannelOpen(String channel) {
         return c.isChannelOpen(channel);
     }
-    
+
     public boolean isUserlistLoaded(String channel) {
         return c.isUserlistLoaded(channel);
     }
-    
+
     public String getHostedChannel(String channel) {
         return c.getChannelState(channel).getHosting();
     }
-    
+
     /**
      * Execute a command from input, which means the text starts with a '/',
      * followed by the command name and comma-separated arguments.
-     * 
+     *
      * Use {@link #commandInput(Room, String, Parameters)} to carry over extra
      * parameters.
-     * 
+     *
      * @param room The room context
      * @param text The raw text
-     * @return 
+     * @return
      */
     public boolean commandInput(Room room, String text) {
         return commandInput(room, text, null);
     }
-    
+
     /**
      * Execute a command from input, which means the text starts with a '/',
      * followed by the command name and comma-separated arguments.
-     * 
+     *
      * @param room The room context
      * @param text The raw text
      * @param parameters The parameters to carry over (args will be overwritten)
-     * @return 
+     * @return
      */
     public boolean commandInput(Room room, String text, Parameters parameters) {
         String[] split = text.split(" ", 2);
@@ -854,7 +847,7 @@
         if (split.length == 2) {
             args = split[1];
         }
-        
+
         // Overwrite args in Parameters with current
         if (parameters == null) {
             parameters = Parameters.create(args);
@@ -863,47 +856,47 @@
         }
         return command(room, command, parameters);
     }
-    
+
     /**
      * Executes the command with the given name, which can be a built-in or
      * Custom command, with no parameters.
-     * 
+     *
      * @param room The room context
      * @param command The command name (no leading /)
-     * @return 
+     * @return
      */
     public boolean command(Room room, String command) {
         return command(room, command, Parameters.create(null));
     }
-    
+
     /**
      * Executes the command with the given name, which can be a built-in or
      * Custom Command.
-     * 
+     *
      * @param room The room context
      * @param command The command name (no leading /)
      * @param parameter The parameter, can be null
-     * @return 
+     * @return
      */
     public boolean command(Room room, String command, String parameter) {
         return command(room, command, Parameters.create(parameter));
     }
-    
+
     /**
      * Executes the command with the given name, which can be a built-in or
      * Custom Command.
-     * 
+     *
      * @param room The room context
      * @param command The command name (no leading /)
      * @param parameters The parameters, can not be null
-     * @return 
+     * @return
      */
     public boolean command(Room room, String command, Parameters parameters) {
         String channel = room.getChannel();
         // Args could be null
         String parameter = parameters.getArgs();
         command = StringUtil.toLowerCase(command);
-        
+
         //---------------
         // Connection/IRC
         //---------------
@@ -1009,7 +1002,7 @@
         else if (command.equals("appinfo")) {
             g.printSystem(LogUtil.getAppInfo()+" [Connection] "+c.getConnectionInfo());
         }
-        
+
         //-----------------------
         // Settings/Customization
         //-----------------------
@@ -1031,13 +1024,13 @@
         else if (command.equals("remove")) {
             g.printSystem(settings.removeTextual(parameter));
         }
-        
+
         else if (command.equals("setcolor")) {
             if (parameter != null) {
                 g.setColor(parameter);
             }
         }
-        
+
         else if (command.equals("setname")) {
             g.printLine(customNames.commandSetCustomName(parameter));
         }
@@ -1056,7 +1049,7 @@
             g.printSystem("[Addressbook] Importing from file..");
             addressbook.importFromFile();
         }
-        
+
         //-------
         // Ignore
         //-------
@@ -1078,7 +1071,7 @@
         else if (command.equals("unignorewhisper")) {
             commandSetIgnored(parameter, "whisper", false);
         }
-        
+
         //--------------
         // Emotes/Images
         //--------------
@@ -1116,7 +1109,7 @@
             ImageCache.clearCache("emote_"+parameter);
             g.printLine("Emoticon image cache for type "+parameter+" cleared.");
         }
-        
+
         //------
         // Other
         //------
@@ -1179,15 +1172,15 @@
         else if (command.equals("proc")) {
             g.printSystem("[Proc] "+ProcessManager.command(parameter));
         }
-        
+
         else if (c.command(channel, command, parameter, null)) {
             // Already done if true
         }
-        
+
         else if (g.commandGui(channel, command, parameter)) {
             // Already done if true :P
         }
-        
+
         else if (command.equals("chain")) {
             List<String> commands = Helper.getChainedCommands(parameter);
             if (commands.isEmpty()) {
@@ -1203,7 +1196,7 @@
         else if (customCommands.containsCommand(command, room)) {
             customCommand(room, command, parameters);
         }
-        
+
         else if (command.equals("debug")) {
             String[] split = parameter.split(" ", 2);
             String actualCommand = split[0];
@@ -1213,21 +1206,21 @@
             }
             testCommands(room, actualCommand, actualParamter);
         }
-        
+
         //--------------------
         // Only for testing
         else if (Chatty.DEBUG || settings.getBoolean("debugCommands")) {
             testCommands(room, command, parameter);
         }
         //----------------------
-        
+
         else {
             g.printLine(Language.getString("chat.unknownCommand", command));
             return false;
         }
         return true;
     }
-    
+
     private void testCommands(Room room, String command, String parameter) {
         String channel = room.getChannel();
         if (command.equals("addchans")) {
@@ -1508,7 +1501,7 @@
             c.debugConnection();
         }
     }
-    
+
     private void anonCustomCommand(Room room, String text, Parameters parameters) {
         CustomCommand command = CustomCommand.parse(text);
         if (parameters == null) {
@@ -1516,7 +1509,7 @@
         }
         anonCustomCommand(room, command, parameters);
     }
-    
+
     public void anonCustomCommand(Room room, CustomCommand command, Parameters parameters) {
         if (command.hasError()) {
             g.printLine("Custom command invalid: "+command.getError());
@@ -1535,7 +1528,7 @@
             textInput(room, result, parameters);
         }
     }
-    
+
     public void customCommand(Room room, String command, Parameters parameters) {
         if (room == null) {
             g.printLine("Custom command: Not on a channel");
@@ -1568,12 +1561,12 @@
             }
         }
     }
-    
+
     /**
      * Adds or removes the name given in the parameter on the ignore list. This
      * is done for either regular ignores (chat) and/or whisper ignores
      * depending on the given type.
-     * 
+     *
      * Outputs a message with the new state depending on whether any change (at
      * least one list was changed) occured or not.
      *
@@ -1628,7 +1621,7 @@
             g.printSystem("Ignore: Invalid name");
         }
     }
-    
+
     private void commandServer(String parameter) {
         if (parameter == null) {
             g.printLine("Usage: /server <address>[:port]");
@@ -1643,11 +1636,11 @@
             g.printLine("Invalid format. Usage: /server <address>[:port]");
         }
     }
-    
+
     /**
      * Command to join channel entered.
-     * 
-     * @param channel 
+     *
+     * @param channel
      */
     public void commandJoinChannel(String channelString) {
         if (channelString == null) {
@@ -1659,14 +1652,14 @@
                 channel = StringUtil.toLowerCase(channel.trim());
                 c.joinChannel(channel);
             }
-            
+
         }
     }
-    
+
     /**
      * Command to part channel entered.
-     * 
-     * @param channel 
+     *
+     * @param channel
      */
     private void commandPartChannel(String channel) {
         if (channel == null || channel.isEmpty()) {
@@ -1678,7 +1671,7 @@
 
     /**
      * React to action message (/me) command and send message if on channel.
-     * 
+     *
      * @param channel The channel to send the message to
      * @param message The message to send
      */
@@ -1689,7 +1682,7 @@
             g.printLine("Usage: /me <message>");
         }
     }
-    
+
     public void sendActionMessage(String channel, String message) {
         if (c.onChannel(channel, true)) {
             if (c.sendSpamProtectedMessage(channel, message, true)) {
@@ -1699,7 +1692,7 @@
             }
         }
     }
-    
+
     private void commandCustomMessage(String parameter) {
         if (parameter != null && !parameter.isEmpty()) {
             String[] split = parameter.split(" ", 2);
@@ -1713,7 +1706,7 @@
         }
         g.printSystem("Invalid parameters.");
     }
-    
+
     public void commandReconnect() {
         if (c.disconnect()) {
             c.reconnect();
@@ -1721,7 +1714,7 @@
             g.printLine("Could not reconnect.");
         }
     }
-    
+
     private void commandCustomCompletion(String parameter) {
         String usage = "Usage: /customCompletion <add/set/remove> <item> <value>";
         if (parameter == null) {
@@ -1754,13 +1747,13 @@
             }
         }
     }
-    
+
     /**
      * Follows the stream given in the parameter, or the channel if no parameter
      * is given.
-     * 
+     *
      * @param channel
-     * @param parameter 
+     * @param parameter
      */
     public void commandFollow(String channel, String parameter) {
         String user = settings.getString("username");
@@ -1778,7 +1771,7 @@
         }
         api.followChannel(user, target);
     }
-    
+
     public void commandUnfollow(String channel, String parameter) {
         String user = settings.getString("username");
         String target = Helper.toStream(channel);
@@ -1795,15 +1788,15 @@
         }
         api.unfollowChannel(user, target);
     }
-    
+
     public void commandAddStreamHighlight(Room room, String parameter) {
         g.printLine(room, streamHighlights.addHighlight(room.getOwnerChannel(), parameter));
     }
-    
+
     public void commandOpenStreamHighlights(Room room) {
         g.printLine(room, streamHighlights.openFile());
     }
-    
+
     public void modCommandAddStreamHighlight(User user, String message) {
         // Stream Highlights
         String result = streamHighlights.modCommand(user, message);
@@ -1816,7 +1809,7 @@
             }
         }
     }
-    
+
     public void commandAddStreamMarker(Room room, String description) {
         api.createStreamMarker(room.getStream(), description, error -> {
             String info = StringUtil.aEmptyb(description, "no description", "'%s'");
@@ -1827,7 +1820,7 @@
             }
         });
     }
-    
+
     private void commandRefresh(String channel, String parameter) {
         if (!Helper.isRegularChannel(channel)) {
             channel = null;
@@ -1880,11 +1873,11 @@
             g.printLine("Usage: /refresh <type> (invalid type, see help)");
         }
     }
-    
+
     public User getSpecialUser() {
         return c.getSpecialUser();
     }
-    
+
     /**
      * Outputs the emotesets for the local user. This might not work correctly
      * if the user is changed or the emotesets change during the session.
@@ -1914,7 +1907,7 @@
             g.printLine(b.toString());
         }
     }
-    
+
     private void commandFFZ(String channel) {
         Set<Emoticon> output;
         StringBuilder b = new StringBuilder();
@@ -1937,7 +1930,7 @@
         }
         g.printLine(roomManager.getRoom(channel), b.toString());
     }
-    
+
     private void commandFFZFollowing(String channel, String parameter) {
         String stream = Helper.toStream(channel);
         if (stream == null) {
@@ -1957,8 +1950,8 @@
      * Add a debugmessage to the GUI. If the GUI wasn't created yet, add it
      * to a cache that is send to the GUI once it is created. This is done
      * automatically when a debugmessage is added after the GUI was created.
-     * 
-     * @param line 
+     *
+     * @param line
      */
     public void debug(String line) {
         if (shuttingDown) {
@@ -2021,7 +2014,7 @@
             }
         }
     }
-    
+
     private class PubSubResults implements PubSubListener {
 
         @Override
@@ -2032,11 +2025,11 @@
                     String channel = Helper.toChannel(data.stream);
                     g.printModerationAction(data, data.created_by.equals(c.getUsername()));
                     chatLog.modAction(data);
-                    
+
                     User modUser = c.getUser(channel, data.created_by);
                     modUser.addModAction(data);
                     g.updateUserinfo(modUser);
-                    
+
                     String bannedUsername = ModLogInfo.getBannedUsername(data);
                     if (bannedUsername != null) {
                         // If this is actually a ban, add info to banned user
@@ -2052,14 +2045,14 @@
         public void info(String info) {
             g.printDebugPubSub(info);
         }
-        
+
     }
-    
+
     /**
      * Redirects request results from the API.
      */
     private class TwitchApiResults implements TwitchApiResultListener {
-        
+
         @Override
         public void receivedEmoticons(Set<Emoticon> emoticons) {
             g.addEmoticons(emoticons);
@@ -2068,27 +2061,27 @@
                 refreshRequests.remove("emoticons");
             }
         }
-        
+
         @Override
         public void tokenVerified(String token, TokenInfo tokenInfo) {
             g.tokenVerified(token, tokenInfo);
         }
-        
+
         @Override
         public void tokenRevoked(String error) {
             // TODO
         }
-        
+
         @Override
         public void runCommercialResult(String stream, String text, RequestResultCode result) {
             commercialResult(stream, text, result);
         }
-        
+
         @Override
         public void receivedChannelInfo(String stream, ChannelInfo info, RequestResultCode result) {
             g.setChannelInfo(stream, info, result);
         }
-    
+
         @Override
         public void putChannelInfoResult(RequestResultCode result) {
             g.putChannelInfoResult(result);
@@ -2118,12 +2111,12 @@
             followerInfoNames(followerInfo);
             receivedFollowerOrSubscriberCount(followerInfo);
         }
-        
+
         /**
          * Set follower/subscriber count in StreamInfo and send to Stream Status
          * Writer.
-         * 
-         * @param followerInfo 
+         *
+         * @param followerInfo
          */
         private void receivedFollowerOrSubscriberCount(FollowerInfo followerInfo) {
             if (followerInfo.requestError) {
@@ -2154,9 +2147,9 @@
         }
 
         private void followerInfoNames(FollowerInfo info) {
-            
+
         }
-        
+
         @Override
         public void receivedFollower(String stream, String username, RequestResultCode result, Follower follower) {
             g.setFollowInfo(stream, username, result, follower);
@@ -2164,7 +2157,7 @@
 
         @Override
         public void receivedDisplayName(String name, String displayName) {
-            
+
         }
 
         @Override
@@ -2212,7 +2205,7 @@
             roomManager.addRoomsInfo(info);
         }
 
-        
+
     }
 
     private class MyRoomUpdatedListener implements RoomManager.RoomUpdatedListener {
@@ -2226,11 +2219,11 @@
                 g.updateRoom(room);
             }
         }
-        
+
     }
-    
+
     // Webserver
-    
+
     public void startWebserver() {
         if (webserver == null) {
             webserver = new Webserver(new WebserverListener());
@@ -2242,7 +2235,7 @@
             g.webserverStarted();
         }
     }
-    
+
     public void stopWebserver() {
         if (webserver != null) {
             webserver.stop();
@@ -2251,7 +2244,7 @@
             LOGGER.info("No webserver running, can't stop it");
         }
     }
-    
+
     private class WebserverListener implements Webserver.WebserverListener {
 
         @Override
@@ -2277,16 +2270,16 @@
     };
 
     private class MyStreamInfoListener implements StreamInfoListener {
-        
+
         private final ConcurrentMap<StreamInfo, Object> notFoundInfoDone
                 = new ConcurrentHashMap<>();
-        
+
         /**
          * The StreamInfo has been updated with new data from the API.
-         * 
+         *
          * This may still hold a lock from the StreamInfoManager.
-         * 
-         * @param info 
+         *
+         * @param info
          */
         @Override
         public void streamInfoUpdated(StreamInfo info) {
@@ -2315,7 +2308,7 @@
          * which should usually be open because only current channels get stream
          * data requested, but check if its still open (request response is
          * delayed and it could have been closed in the meantime).
-         * 
+         *
          * This may still hold a lock from the StreamInfoManager.
          *
          * @param info
@@ -2329,7 +2322,7 @@
                     g.printLineByOwnerChannel(channel, "~" + newStatus + "~");
                 }
                 g.setChannelNewStatus(channel, newStatus);
-                
+
                 /**
                  * Only do warning/unhost stuff if stream is only at most 15
                  * minutes old. This prevents unhosting at the end of the stream
@@ -2355,7 +2348,7 @@
             g.statusNotification(channel, info);
         }
     }
-    
+
     /**
      * Log viewerstats for any open channels, which can be used to log any
      * remaining data on all channels when the program is closed.
@@ -2365,7 +2358,7 @@
             logViewerstats(channel);
         }
     }
-    
+
     /**
      * Gets the viewerstats for the given channel and logs them. This can be
      * used to log any remaining data when a channel is closed or the program is
@@ -2382,7 +2375,7 @@
 
     /**
      * For testing. This requires Chatty.DEBUG and Chatty.HOTKEY to be enabled.
-     * 
+     *
      * If enabled, AltGr+T can be used to trigger this method.
     */
     public void testHotkey() {
@@ -2394,12 +2387,12 @@
         g.showTokenWarning();
         //g.testHotkey();
     }
-    
+
     /**
      * Tries to run a commercial on the given stream with the given length.
-     * 
+     *
      * Outputs a message about it in the appropriate channel.
-     * 
+     *
      * @param stream The stream to run the commercial in
      * @param length The length of the commercial in seconds
      */
@@ -2417,18 +2410,18 @@
             api.runCommercial(stream, length);
         }
     }
-    
+
     /**
      * Work with the result on trying to run a commercial, which mostly is
      * returned by the Twitch API, but may also be immediately called if
      * something is formally wrong (like no or empty stream name specified).
-     * 
+     *
      * Outputs an info text about the result to the appropriate channel and
      * tells the GUI so a message can be displayed in the admin dialog.
-     * 
+     *
      * @param stream
      * @param text
-     * @param result 
+     * @param result
      */
     private void commercialResult(String stream, String text, RequestResultCode result) {
         String channel = "#"+stream;
@@ -2439,7 +2432,7 @@
         }
         g.commercialResult(stream, text, result);
     }
-    
+
     /**
      * Receive FrankerFaceZ emoticons and icons.
      */
@@ -2485,10 +2478,10 @@
             g.printSystem("FFZ: "+info);
         }
     }
-    
+
     /**
      * Requests the third-party emotes for the channel, if enabled.
-     * 
+     *
      * @param channel The name of the channel (can be stream or channel)
      */
     public void requestChannelEmotes(String channel) {
@@ -2501,7 +2494,7 @@
         }
         api.getEmotesByStreams(Helper.toStream(channel));
     }
-    
+
     private class EmoteListener implements EmoticonListener {
 
         @Override
@@ -2520,9 +2513,9 @@
                 botNameManager.addBotNames(channel, names);
             }
         }
-        
+
     }
-    
+
     private class TwitchemotesListener implements TwitchEmotesListener {
 
         @Override
@@ -2534,24 +2527,24 @@
             g.setEmotesets(info);
             api.setEmotesetInfo(info);
         }
-        
+
     }
-    
+
     /**
      * Only used for testing. You have to restart Chatty for the spam protection
      * in the connectin to change.
-     * 
-     * @param value 
+     *
+     * @param value
      */
     public void setLinesPerSeconds(String value) {
         spamProtection.setLinesPerSeconds(value);
         c.setSpamProtection(value);
     }
-    
+
     /**
      * Exit the program. Do some cleanup first and save stuff to file (settings,
      * addressbook, chatlogs).
-     * 
+     *
      * Should run in EDT.
      */
     public void exit() {
@@ -2565,10 +2558,10 @@
         chatLog.close();
         System.exit(0);
     }
-    
+
     /**
      * Save all settings to file.
-     * 
+     *
      * @param onExit If true, this will save the settings only if they haven't
      * already been saved with this being true before
      */
@@ -2579,10 +2572,10 @@
             }
             settingsAlreadySavedOnExit = true;
         }
-        
+
         LOGGER.info("Saving settings..");
         System.out.println("Saving settings..");
-        
+
         // Prepare saving settings
         if (g != null && g.guiCreated) {
             g.saveWindowStates();
@@ -2593,7 +2586,7 @@
             settings.saveSettingsToJson();
         }
     }
-    
+
     private class SettingSaveListener implements SettingsListener {
 
         @Override
@@ -2607,9 +2600,9 @@
             settings.setString("previousChannel", Helper.buildStreamsString(openChans));
             EmoticonSizeCache.saveToFile();
         }
-        
+
     }
-    
+
     private class Messages implements TwitchConnection.ConnectionListener {
 
         private void checkModLogListen(User user) {
@@ -2618,16 +2611,16 @@
                 pubsub.listenModLog(user.getStream(), settings.getString("token"));
             }
         }
-        
+
         @Override
         public void onChannelJoined(User user) {
             channelFavorites.addJoined(user.getRoom());
-            
+
             g.printLine(user.getRoom(), Language.getString("chat.joined", user.getRoom()));
             if (user.getRoom().hasTopic()) {
                 g.printLine(user.getRoom(), user.getRoom().getTopicText());
             }
-            
+
             // Icons and FFZ/BTTV Emotes
             //api.requestChatIcons(Helper.toStream(channel), false);
             api.getGlobalBadges(false);
@@ -2723,7 +2716,7 @@
                 g.addUser(user);
             }
         }
-        
+
         private boolean showUserInGui(User user) {
             if (!settings.getBoolean("ignoredUsersHideInGUI")) {
                 return true;
@@ -2749,7 +2742,7 @@
             chatLog.userBanned(user.getRoom().getFilename(), user.getRegularDisplayNick(),
                     duration, reason, channelInfo);
         }
-        
+
         @Override
         public void onMsgDeleted(User user, String targetMsgId, String msg) {
             User localUser = c.getLocalUser(user.getChannel());
@@ -2760,7 +2753,7 @@
             }
             chatLog.msgDeleted(user, msg);
         }
-        
+
         @Override
         public void onRegistered() {
             g.updateHighlightSetUsername(c.getUsername());
@@ -2855,7 +2848,7 @@
         @Override
         public void onHost(Room room, String target) {
         }
-        
+
         @Override
         public void onChannelCleared(Room room) {
             if (room != null) {
@@ -2900,7 +2893,7 @@
                         name, cat));
             }
         }
-        
+
         @Override
         public void onUsernotice(String type, User user, String text, String message, String emotes) {
             g.printUsernotice(type, user, text, message, emotes);
@@ -2917,18 +2910,18 @@
                 api.setUserId(Helper.toStream(channel), id);
             }
         }
-        
+
     }
-    
+
     private class IrcLogger {
-        
+
         private final Logger IRC_LOGGER = Logger.getLogger(TwitchClient.IrcLogger.class.getName());
-        
+
         IrcLogger() {
             IRC_LOGGER.setUseParentHandlers(false);
             IRC_LOGGER.addHandler(Logging.getIrcFileHandler());
         }
-        
+
         public void onRawReceived(String text) {
             if (settings.getBoolean("debugLogIrc")) {
                 g.printDebugIrc(">> " + text);
@@ -2937,7 +2930,7 @@
                 IRC_LOGGER.info(">> " + text);
             }
         }
-        
+
         public void onRawSent(String text) {
             if (settings.getBoolean("debugLogIrc")) {
                 g.printDebugIrc("<<< " + text);
@@ -2946,17 +2939,17 @@
                 IRC_LOGGER.info("SENT: " + text);
             }
         }
-        
+
     }
-    
+
     public ChannelState getChannelState(String channel) {
         return c.getChannelState(channel);
     }
-    
+
     public Collection<String> getOpenChannels() {
         return c.getOpenChannels();
     }
-    
+
     private class ChannelStateUpdater implements ChannelStateListener {
 
         @Override
@@ -2965,11 +2958,11 @@
         }
 
     }
-    
+
     public boolean isWhisperAvailable() {
         return w.isAvailable();
     }
-    
+
     private class MyWhisperListener implements WhisperListener {
 
         @Override
@@ -2988,5 +2981,5 @@
             g.printMessage(to, message, true, null, 0);
         }
     }
-    
+
 }
--- a/src/chatty/gui/components/updating/Version.java
+++ b/src/chatty/gui/components/updating/Version.java
@@ -14,39 +14,39 @@
 
 /**
  * Request a version file and check if it's a new version.
- * 
+ *
  * @author tduva
  */
 public class Version {
 
     private static final Logger LOGGER = Logger.getLogger(Version.class.getName());
-    
+
     /**
      * The interval to check version in (seconds)
      */
     private static final int CHECK_VERSION_INTERVAL = 60*60*24*2;
-    
+
     private static final String VERSION = Chatty.VERSION;
-    
+
     private final VersionListener listener;
     private final Settings settings;
-    
+
     private Version(VersionListener listener, Settings settings) {
         this.listener = listener;
         this.settings = settings;
         //versionReceived("0.3.1 Auto updater, Bugfixes");
     }
-    
+
     public static void check(Settings settings, VersionListener listener) {
         Version v = new Version(listener, settings);
         v.checkForNewVersion();
     }
-    
+
     public static void request(Settings settings, VersionListener listener) {
         Version v = new Version(listener, settings);
         v.checkForNewVersionForced();
     }
-    
+
     private void checkForNewVersion() {
         if (!settings.getBoolean("checkNewVersion")) {
             return;
@@ -67,7 +67,7 @@
             checkForNewVersionForced();
         }
     }
-    
+
     public void checkForNewVersionForced() {
         settings.setLong("versionLastChecked", System.currentTimeMillis());
         LOGGER.log(USERINFO, "Checking for new version..");
@@ -77,12 +77,12 @@
             versionReceived(GitHub.getReleases());
         }).start();
     }
-    
+
     /**
      * Works with the received version String and compares it to the
      * current version. Expects a version in the format: "x.y.z info text"
      * ("info text" is optional).
-     * 
+     *
      * @param versionChecked The version String as received from the server
      */
     private void versionReceived(Releases releases) {
@@ -97,18 +97,18 @@
         if (isNewVersion) {
             settings.setString("updateAvailable", release.getVersion());
         }
-        LOGGER.info(String.format("[UpdateCheck] Current: %s Latest: %s",
-                VERSION, release.getVersion()));
-        listener.versionChecked(isNewVersion ? release.getVersion() : null, releases);
+        //LOGGER.info(String.format("[UpdateCheck] Current: %s Latest: %s",
+        //        VERSION, release.getVersion()));
+        //listener.versionChecked(isNewVersion ? release.getVersion() : null, releases);
     }
-    
+
     /**
      * Compare version1 to version2 and return 1 if version2 is greater, -1
      * if version1 is greater and 0 if they are equal.
-     * 
+     *
      * @param version1
      * @param version2
-     * @return 
+     * @return
      */
     public static int compareVersions(String version1, String version2) {
         int[] v1 = versionToIntArray(version1);
@@ -140,17 +140,17 @@
         }
         return 0;
     }
-    
+
     /**
      * Convert a version in the form "x.y.z" (any length) into an array of
      * integers "[x, y, z]".
-     * 
+     *
      * The version may end in any letters and an optional number, optionally
      * separated by a dash (-), with the number put at the end of the array,
      * with a -1 as separator ("0.8.5b3" -> "[0, 8, 5, -1, 3]").
-     * 
+     *
      * @param version
-     * @return 
+     * @return
      */
     public static int[] versionToIntArray(String version) {
         int betaVersion = 0;
@@ -163,10 +163,10 @@
             }
             version = m.group(1);
         }
-        
+
         String[] split = version.split("\\.");
         int[] intVersion = new int[split.length+(betaVersion > 0 ? 2 : 0)];
-        
+
         for (int i=0;i<split.length;i++) {
             String part = split[i];
             int partI = 0;
@@ -183,9 +183,9 @@
         }
         return intVersion;
     }
-    
+
     public static interface VersionListener {
         public void versionChecked(String newVersion, GitHub.Releases releases);
     }
-    
+
 }
