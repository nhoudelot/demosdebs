Description: generate minifier version of shader
Author: Nicolas HOUDELOT <nicolas@demosdebs.org>
Applied-Upstream: no
Last-Update: 2024-03-29
---
This patch header follows DEP-3: http://dep.debian.net/deps/dep3/
--- /dev/null
+++ b/out.h
@@ -0,0 +1,21 @@
+/* File generated with Shader Minifier 1.2
+ * http://www.ctrl-alt-test.fr
+ */
+#ifndef OUT_H_
+# define OUT_H_
+
+const char *out_glsl =
+ "uniform sampler2D B;"
+ "uniform vec3 V;"
+ "uniform float TPCT;"
+ "void main()"
+ "{"
+   "if(gl_FragCoord.y<10.)"
+     "{"
+       "gl_FragColor=vec4(step(gl_FragCoord.x/V.x,TPCT));"
+       "return;"
+     "}"
+   "gl_FragColor=texture2D(B,gl_FragCoord.xy/V.xy);"
+ "}";
+
+#endif // OUT_H_
--- /dev/null
+++ b/post.h
@@ -0,0 +1,27 @@
+/* File generated with Shader Minifier 1.2
+ * http://www.ctrl-alt-test.fr
+ */
+#ifndef POST_H_
+# define POST_H_
+
+const char *post_glsl =
+ "uniform sampler2D B;"
+ "uniform vec3 V,D;"
+ "void main()"
+ "{"
+   "vec2 v=gl_FragCoord.xy/V.xy,c=.002*vec2(V.y/V.x,1.),f=vec2(0.,1.1);"
+   "vec4 r=vec4(0.);"
+   "float i=0.;"
+   "mat2 m=mat2(cos(2.4),sin(2.4),-sin(2.4),cos(2.4));"
+   "for(int s=0;s<256;s++)"
+     "{"
+       "vec4 a=texture2D(B,v+c*i*f);"
+       "if(abs(50.*(D.z-a.w)/a.w/(D.z-.5))>i)"
+         "r+=vec4(a.xyz,1.);"
+       "i+=1./(i+1.);"
+       "f*=m;"
+     "}"
+   "gl_FragColor=vec4(pow(r.xyz/(r.xyz+r.w),vec3(1./2.2)),1.);"
+ "}";
+
+#endif // POST_H_
--- /dev/null
+++ b/raymarch.h
@@ -0,0 +1,219 @@
+/* File generated with Shader Minifier 1.2
+ * http://www.ctrl-alt-test.fr
+ */
+#ifndef RAYMARCH_H_
+# define RAYMARCH_H_
+
+const char *raymarch_glsl =
+ "uniform vec3 V,C,A,D;"
+ "float v=V.z;"
+ "const vec3 m=vec3(0.,.001,1.);"
+ "const float f=3.141593;"
+ "float x(float v)"
+ "{"
+   "return fract(sin(v)*43758.5);"
+ "}"
+ "float s(vec2 v)"
+ "{"
+   "return fract(sin(17.*x(v.x)+54.*x(v.y)));"
+ "}"
+ "float n(vec2 v)"
+ "{"
+   "vec2 a=floor(v);"
+   "v-=a;"
+   "return mix(mix(s(a),s(a+m.zx),v.x),mix(s(a+m.xz),s(a+m.zz),v.x),v.y);"
+ "}"
+ "float t(float v)"
+ "{"
+   "float a=floor(v);"
+   "v-=a;"
+   "return mix(x(a),x(a+1.),v);"
+ "}"
+ "vec3 p(float v)"
+ "{"
+   "return vec3(t(v),t(v+13.),t(v+29.));"
+ "}"
+ "float n(vec3 v,vec3 x)"
+ "{"
+   "return v=abs(v)-x,max(v.x,max(v.y,v.z));"
+ "}"
+ "mat3 r(float v)"
+ "{"
+   "float m=sin(v),a=cos(v);"
+   "return mat3(a,0.,m,0.,1.,0,-m,0.,a);"
+ "}"
+ "float p(vec3 v,float x)"
+ "{"
+   "return length(v)-x;"
+ "}"
+ "vec3 r(vec3 v,vec3 x)"
+ "{"
+   "return mod(v,x)-x*.5;"
+ "}"
+ "float n(vec3 v,float m,float x,float z)"
+ "{"
+   "float a=length(v);"
+   "return max(abs(v.y)-z,max(a-x,m-a));"
+ "}"
+ "float e(vec2 v)"
+ "{"
+   "return max(v.x,v.y);"
+ "}"
+ "float i(vec3 a)"
+ "{"
+   "const float x=2.8;"
+   "const int z=5;"
+   "vec3 f=vec3(1.1,.9,1.9);"
+   "for(int i=0;i<z;++i)"
+     "{"
+       "a=a*r(.1+v*.3);"
+       "a=abs(a);"
+       "a.xy+=step(a.x,a.y)*(a.yx-a.xy);"
+       "a.xz+=step(a.x,a.z)*(a.zx-a.xz);"
+       "a.yz+=step(a.y,a.z)*(a.zy-a.yz);"
+       "a=a*r(.7);"
+       "a.xy=a.xy*x-(x-1.)*f.xy;"
+       "a.z=x*a.z;"
+       "if(a.z>.5*f.z*(x-1.))"
+         "a.z-=f.z*(x-1.);"
+     "}"
+   "return n(a,m.zzz)*pow(x,-float(z));"
+ "}"
+ "int a=0;"
+ "void e(inout float v,float m,int x)"
+ "{"
+   "if(m<v)"
+     "v=m,a=x;"
+ "}"
+ "float d(vec3 v)"
+ "{"
+   "float a=e(abs(v.xy)-vec2(2.,.1));"
+   "a=a+max(0.,.2*n(r(v,vec3(.15)),vec3(.01)));"
+   "v.x=abs(v.x)+.02;"
+   "float x=e(abs(v.xy-vec2(2.,1.))-vec2(.02)),z=max(abs(mod(v.z,.4)-.2)-.02,max(abs(v.y-.5)-.5,abs(v.x-2.)-.02));"
+   "return min(a,min(x,z));"
+ "}"
+ "float h(vec3 v)"
+ "{"
+   "return n(v-vec3(33.,1.6,0.),vec3(20.,1.5,1.96));"
+ "}\n"
+ "#define LN 5\n"
+ "vec3 c[LN],l[LN];"
+ "float w(vec3 v)"
+ "{"
+   "float a=1e5;"
+   "for(int f=0;f<LN;++f)"
+     "e(a,length(v-c[f])-.1,f+100);"
+   "float x=length(v.xz),m=atan(v.x,v.z),f=length(v),z=-min(h(vec3(abs(v.x),v.yz)),h(vec3(abs(v.z),v.yx))),s=max(-p(v,19.),n(r(v,vec3(2.)),vec3(.8))),A=-p(v,20.);"
+   "e(a,A,1);"
+   "e(a,s,2);"
+   "a=max(z,a);"
+   "float l=p(v,9.);"
+   "l=max(l,abs(abs(v.y)-3.)-.5);"
+   "l=min(l,n(r(v,vec3(11.8)),vec3(.1,100.,.1)));"
+   "l=max(l,-p(v,8.9));"
+   "float t=d(vec3(x-13.,v.y,m*10.));"
+   "t=min(t,max(15.-x,min(d(v.zyx),d(v))));"
+   "t=max(t,z);"
+   "e(a,l,3);"
+   "e(a,t,4);"
+   "if(f<2.*D.x)"
+     "e(a,i(v/D.x)*D.x,5);"
+   "else"
+     " a=min(a,f+1.);"
+   "return a;"
+ "}"
+ "float d(float v,float a)"
+ "{"
+   "a*=a;"
+   "a*=a;"
+   "float x=v*v*(a-1.)+1.;"
+   "x=f*x*x;"
+   "return a/x;"
+ "}"
+ "float e(float v,float m)"
+ "{"
+   "return m+=1.,m*=m/8.,v/(v*(1.-m)+m);"
+ "}"
+ "vec3 d(vec3 v,vec3 m,float x)"
+ "{"
+   "float a=0.,f=1e3;"
+   "int z;"
+   "for(z=0;z<128;++z)"
+     "{"
+       "vec3 i=v+m*a;"
+       "float s=w(i);"
+       "a+=s;"
+       "f=min(f,s);"
+       "if(s<.002*a||a>x)"
+         "break;"
+     "}"
+   "return vec3(a,f,float(z));"
+ "}"
+ "mat3 h(vec3 v,vec3 x,vec3 a)"
+ "{"
+   "vec3 m=normalize(v-x),z=normalize(cross(a,m));"
+   "a=cross(m,z);"
+   "return mat3(z,a,m);"
+ "}"
+ "void main()"
+ "{"
+   "vec2 x=gl_FragCoord.xy/V.xy*2.-1.;"
+   "x.x*=V.x/V.y;"
+   "c[0]=vec3(11.,6.,11.);"
+   "c[1]=vec3(11.,6.,-11.);"
+   "c[2]=vec3(-11.,6.,-11.);"
+   "c[3]=vec3(-11.,6.,11.);"
+   "c[4]=m.xxx;"
+   "l[0]=vec3(.7,.35,.45);"
+   "l[1]=vec3(.7,.35,.15);"
+   "l[2]=vec3(.3,.35,.75);"
+   "l[3]=vec3(.7,.35,.15);"
+   "l[4]=vec3(D.x);"
+   "vec3 z=C+.1*p(v*3.);"
+   "mat3 i=h(z,A,m.xzx);"
+   "vec3 s=-i*normalize(vec3(x,-D.y)),y=d(z,-s,40.),N=z-y.x*s,b=m.xxx,o=m.xxx;"
+   "float L=0.,u=0.,g=w(N);"
+   "vec3 F=normalize(vec3(w(N+m.yxx),w(N+m.xyx),w(N+m.xxy))-g);"
+   "if(a==1)"
+     "o=vec3(.5),u=.4,L=.99;"
+   "else"
+     " if(a==2)"
+       "o=vec3(.56,.57,.58),u=mix(.15,.5,step(n(r(N,vec3(2.)),vec3(.6)),0.)),L=.8;"
+     "else"
+       " if(a==3)"
+         "{"
+           "float q=step(0.,sin(atan(N.x,N.z)*60.));"
+           "o=vec3(mix(1.,.1,q));"
+           "u=mix(.9,.2,q);"
+           "L=.1;"
+         "}"
+       "else"
+         " if(a==4)"
+           "o=vec3(.56,.57,.58),u=.2+.6*pow(n(N.xz*4.+40.),4.),L=.8;"
+         "else"
+           " if(a==5)"
+             "o=vec3(1.,0.,0.),u=.2,L=.8;"
+           "else"
+             " for(int q=0;q<LN;++q)"
+               "if(a==100+q)"
+                 "b=l[q]*30.;"
+   "for(int q=0;q<LN;++q)"
+     "{"
+       "vec3 k=c[q]-N;"
+       "float Z=dot(k,k),Y=sqrt(Z);"
+       "k=normalize(k);"
+       "vec3 X=d(N+.02*k,k,Y);"
+       "if(X.x+.2<Y)"
+         "continue;"
+       "vec3 W=normalize(s+k),U=mix(vec3(.04),o,L);"
+       "float T=max(dot(W,s),0.),S=max(dot(F,s),0.),R=max(dot(F,k),0.),Q=max(dot(F,W),0.);"
+       "vec3 P=U+(1.-U)*pow(1.-T,5.);"
+       "float O=e(S,u)*e(R,u);"
+       "vec3 M=d(Q,u)*O*P/(4.*S*R+.001);"
+       "b+=30.*(.7+.3*t(v*20.+float(q)))*((vec3(1.)-P)*(1.-L)*o/f+M)*R*l[q]/Z;"
+     "}"
+   "gl_FragColor=vec4(b,y.x);"
+ "}";
+
+#endif // RAYMARCH_H_
